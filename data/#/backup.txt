package main

import (
	"bufio"
	"bytes"
	"crypto/tls"
	"fmt"
	"math/rand"
	"net/http"
	"os"
	"sync"
	"syscall"
	"time"
	"unsafe"
)

var kernel32 = syscall.NewLazyDLL("kernel32.dll")
var procSetConsoleTitleW = kernel32.NewProc("SetConsoleTitleW")

func setConsoleTitle(title string) {
	titlePtr, _ := syscall.UTF16PtrFromString(title)
	procSetConsoleTitleW.Call(uintptr(unsafe.Pointer(titlePtr)))
}

func main() {
	proxies, err := loadProxies("data/proxies.txt")
	if err != nil {
		panic(err)
	}

	targets, err := loadTargets("data/targets.txt")
	if err != nil {
		panic(err)
	}

	headers := map[string]string{
		//"Kdt":                                "tP6jupowsB8ZGMA2LMghaMBPIXJQWEUWbvXlRear",
		// "X-Twitter-Client-Deviceid": "00000000-0000-0000-0000-000000000000",
		// "X-Client-Uuid":             "799DBDEA-ED6D-4E88-A0CC-C86FC260006E",
		// "X-B3-Traceid":                       "3dc8845fbb29ec5d",
		"Host":                               "api-0-4-7.twitter.com",
		"Accept":                             "application/json",
		"X-Twitter-Client-Version":           "9.44",
		"X-Twitter-Client-Language":          "en",
		"Accept-Language":                    "en",
		"User-Agent":                         "Twitter-iPhone/9.44 iOS/14.8.1 (Apple;iPhone10,4;;;;;1;2017)",
		"X-Twitter-Client-Limit-Ad-Tracking": "1",
		"X-Twitter-Api-Version":              "5",
		"X-Twitter-Client":                   "Twitter-iPhone",
	}
	var data = []byte(nil)

	numConcurrentRequests := 1000
	batchSize := 20
	totalRequestLimit := 1000000

	var requestCount int
	var mu sync.Mutex

	var wg sync.WaitGroup
	wg.Add(numConcurrentRequests)

	startTime := time.Now()
	lastUpdateTime := startTime
	lastRequestCount := 0

	for i := 0; i < numConcurrentRequests; i++ {
		go func() {
			defer wg.Done()

			client := createHTTPClient()
			for {
				targetBatch := getNextTargets(&targets, batchSize)
				if len(targetBatch) == 0 {
					return // No more targets to process
				}

				for _, target := range targetBatch {
					mu.Lock()
					if requestCount >= totalRequestLimit {
						mu.Unlock()
						return // Stop processing requests
					}
					requestCount++
					mu.Unlock()

					targetURL := "https://api-0-4-7.twitter.com:443/i/users/username_available.json?context=signup&custom=1&send_error_codes=1&suggest=1&username=" + target
					response := httpRequest(client, targetURL, "GET", data, headers, getRandomProxy(proxies))

					fmt.Printf("Thread: Code: %d, URL: %s\n", response.StatusCode, target)

					currentTime := time.Now()
					elapsedTime := currentTime.Sub(lastUpdateTime).Seconds()
					if elapsedTime >= 1.0 {
						rps := float64(requestCount-lastRequestCount) / elapsedTime
						setConsoleTitle(fmt.Sprintf("Request Count: %d | RPS: %.2f", requestCount, rps))
						lastRequestCount = requestCount
						lastUpdateTime = currentTime
					}
				}
			}
		}()
	}

	wg.Wait()
}

func createHTTPClient() *http.Client {
	transport := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		MaxIdleConns:    100,
		IdleConnTimeout: 30 * time.Second,
	}
	return &http.Client{Transport: transport}
}

func getNextTargets(allTargets *[]string, batchSize int) []string {
	targets := []string{}
	for i := 0; i < batchSize && len(*allTargets) > 0; i++ {
		targets = append(targets, (*allTargets)[0])
		*allTargets = (*allTargets)[1:]
	}
	return targets
}

func getRandomProxy(proxies []string) string {
	return proxies[rand.Intn(len(proxies))]
}

func httpRequest(client *http.Client, targetUrl string, method string, data []byte, headers map[string]string, proxy string) *http.Response {
	request, error := http.NewRequest(method, targetUrl, bytes.NewBuffer(data))
	if error != nil {
		panic(error)
	}
	for k, v := range headers {
		request.Header.Set(k, v)
	}

	response, error := client.Do(request)
	if error != nil {
		panic(error)
	}
	defer response.Body.Close()

	return response
}

func loadProxies(filename string) ([]string, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var proxies []string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		proxies = append(proxies, scanner.Text())
	}

	return proxies, scanner.Err()
}

func loadTargets(filename string) ([]string, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var targets []string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		targets = append(targets, scanner.Text())
	}

	return targets, scanner.Err()
}
